{
    "name": "angel",
    "questions": [
    {
    "position": 52,
    "topic": "Polymorphism",
    "q": "What is Runtime Polymorphism?",
    "a": "Runtime or Dynamic Polymorphism exists when method calls are resolved at runtime. In method overriding, JVM decides which method to call based on the actual object type, not the reference type.",
    "x": [
      "Polymorphism that occurs when methods are compiled with different bytecode for each subclass.",
      "The ability to create multiple constructors with different parameters in the same class.",
      "Polymorphism achieved by using static methods that change behavior based on compile-time constants."
    ]
  },
  {
    "position": 53,
    "topic": "Polymorphism",
    "q": "Is it possible to achieve Runtime Polymorphism by data members in Java?",
    "a": "No. Runtime Polymorphism is achieved by implementing methods at different levels of inheritance, not through data members.",
    "x": [
      "Yes, by declaring data members as volatile and accessing them through different object references.",
      "Yes, by using final data members that are initialized differently in each subclass constructor.",
      "Yes, by overriding data member declarations using the @Override annotation in subclasses."
    ]
  },
  {
    "position": 54,
    "topic": "Polymorphism",
    "q": "Explain the difference between static and dynamic binding?",
    "a": "Static binding resolves method calls at compile time (e.g., Person p = new Person(); p.walk()). Dynamic binding resolves method calls at runtime based on the actual object type.",
    "x": [
      "Static binding uses inheritance hierarchies while dynamic binding uses interface implementations for method resolution.",
      "Static binding occurs with instance methods while dynamic binding only works with static and final methods.",
      "Static binding resolves at runtime for performance while dynamic binding resolves at compile time for security."
    ]
  }
  ]
}
