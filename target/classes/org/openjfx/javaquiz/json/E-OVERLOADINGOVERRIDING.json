{
    "name": "angel",
    "questions": [
    {
      "position": 1,
        "topic": "Basics",
      "q": "What is the difference between JDK and JRE?",
      "a": "JDK is for developing Java programs (includes compiler, debugger, JRE). JRE is only for running programs (JVM + libraries).",
      "x": [
        "JDK only runs Java programs, JRE compiles them.",
        "JDK is platform independent, JRE is platform dependent.",
        "JDK includes JVM, but JRE does not."
      ]
    },
    {
        "position": 2,
        "topic": "Basics",
      "q": "What is Java Virtual Machine (JVM)?",
      "a": "An abstract machine that executes Java bytecode, making Java platform independent.",
      "x": [
        "A compiler that converts Java code directly into machine code.",
        "A library package included in the JDK for debugging.",
        "A tool that translates JVM bytecode into C++."
      ]
    },
    {
        "position": 3,
            "topic": "Basics",
      "q": "What are the different types of memory areas allocated by JVM?",
      "a": "ClassLoader, Method Area, Heap, Stack, Program Counter, Native Method Stack.",
      "x": [
        "Only Heap and Stack.",
        "RAM, Cache, Disk.",
        "Static memory, Dynamic memory, Shared memory."
      ]
    },
    {
        "position": 4,
            "topic": "Basics",
      "q": "What is JIT compiler?",
      "a": "Just-In-Time compiler, compiles bytecode to native code at runtime for performance.",
      "x": [
        "A compiler used only at install time.",
        "A tool for debugging JVM errors.",
        "A library inside JDK for managing memory."
      ]
    },
    {
        "position": 5,
            "topic": "Basics",
      "q": "How Java platform is different from other platforms?",
      "a": "Java is platform-independent: code compiles to bytecode, runs on any JVM.",
      "x": [
        "Java needs platform-specific libraries to run.",
        "Java programs can run without JVM.",
        "Java is platform dependent like C++."
      ]
    },
     {
         "position": 6,
            "topic": "Basics",
      "q": "Why people say that Java is 'write once and run anywhere' language?",
      "a": "You can write Java code on Windows and compile it in Windows platform. The class and jar files that you get from Windows platform can run as it is on Unix environment. Behind all this portability is Java byte code. Byte code generated by Java compiler can be interpreted by any JVM. So it becomes much easier to write programs in Java and expect those to run on any platform.",
      "x": [
        "Because Java is faster than C++",
        "Because Java runs only on Windows",
        "Because Java compiles directly to machine code"
      ]
    },
    {
        "position": 7,
            "topic": "Basics",
      "q": "How does ClassLoader work in Java?",
      "a": "In Java, ClassLoader is a class that is used to load files in JVM. There are three main types of ClassLoaders: Bootstrap (loads from rt.jar), Extension (loads from jre/lib/ext), and Application (depends on CLASSPATH).",
      "x": [
        "ClassLoader is used only for networking",
        "ClassLoader only loads images",
        "ClassLoader is a keyword in Java"
      ]
    },
    {
        "position": 8,
            "topic": "Basics",
      "q": "Do you think ‘main’ used for main method is a keyword in Java?",
      "a": "No, main is just a name of method. It is not a keyword in Java. There can be multiple methods with same name main in a class file.",
      "x": [
        "Yes, main is a reserved keyword",
        "Yes, main is a datatype",
        "Yes, main is part of the JVM"
      ]
    },
    {
        "position": 9,
            "topic": "Basics",
      "q": "Can we write main method as public void static instead of public static void?",
      "a": "No, you cannot write it like this. Any method has to first specify the modifiers and then the return value. The order of modifiers can change, so static public void main() is valid but not public void static.",
      "x": [
        "Yes, both are valid",
        "Yes, void can go before static",
        "Yes, the order never matters"
      ]
    },
    {
        "position": 10,
            "topic": "Basics",
      "q": "In Java, if we do not specify any value for local variables, then what will be the default value?",
      "a": "Java does not initialize local variables with any default value. You must assign a value before using them.",
      "x": [
        "0 for numbers, false for booleans",
        "null always",
        "It depends on JVM version"
      ]
    },
    {
    "position": 11,
    "topic": "Basics",
    "q": "Let’s say, we run a Java class without passing any arguments. What will be the value of the String array of arguments in the main method?",
    "a": "By default, the String array is empty, not null.",
    "x": [
      "It is null",
      "It contains one empty string",
      "It holds random values"
    ]
  },
    {
      "position": 12,
      "topic": "Basics",
      "q": "What is the difference between byte and char data types in Java?",
      "a": "byte stores binary data (-128 to 127, 8 bits); char stores characters (16 bits, 2 bytes).",
      "x": [
        "byte and char are exactly the same",
        "byte can store characters and char only numbers",
        "char is 8 bits and byte is 16 bits"
      ]
    },
        {
      "position": 13,
      "topic": "OOP",
      "q": "What are the main principles of Object Oriented Programming?",
      "a": "The main OOP principles are Abstraction, Encapsulation, Inheritance, and Polymorphism.",
      "x": [
        "Loops, Conditions, Variables",
        "Compilation, Execution, Linking",
        "HTML, CSS, JavaScript"
      ]
    },
    {
      "position": 14,
      "topic": "OOP",
      "q": "What is the difference between Object Oriented Programming language and Object Based Programming language?",
      "a": "OOP languages support all OOP principles (Abstraction, Encapsulation, Inheritance, Polymorphism); Object-Based languages support objects and encapsulation but not Inheritance and Polymorphism (e.g., JavaScript, VBScript).",
      "x": [
        "OOP languages have no objects",
        "Object-Based languages support Polymorphism and Inheritance",
        "OOP languages cannot use constructors"
      ]
    },
    {
      "position": 15,
      "topic": "OOP",
      "q": "In Java, what is the default value of an object reference defined as an instance variable?",
      "a": "All instance variable object references are null by default.",
      "x": [
        "0",
        "Empty string",
        "Undefined"
      ]
    },
    {
      "position": 16,
      "topic": "OOP",
      "q": "Why do we need a constructor in Java?",
      "a": "Constructors create objects and set their initial state; without them, objects cannot be created.",
      "x": [
        "To destroy objects",
        "To execute main method",
        "To define a class name"
      ]
    },
    {
      "position": 17,
      "topic": "OOP",
      "q": "Why do we need a default constructor in Java classes?",
      "a": "A default constructor (no-argument) is automatically provided if no other constructor exists; it ensures objects can be created when no custom constructor is defined.",
      "x": [
        "It is optional and never used",
        "It deletes all objects",
        "It replaces the main method"
      ]
    },
        {
      "position": 18,
      "topic": "OOP",
      "q": "What is the value returned by a constructor in Java?",
      "a": "A constructor returns the object it creates.",
      "x": [
        "It returns void",
        "It returns a number",
        "It returns a string"
      ]
    },
    {
      "position": 19,
      "topic": "OOP",
      "q": "Can we inherit a constructor in Java?",
      "a": "No, Java does not allow constructors to be inherited.",
      "x": [
        "Yes, always",
        "Only in abstract classes",
        "Only in interfaces"
      ]
    },
    {
      "position": 20,
      "topic": "OOP",
      "q": "Why constructors cannot be final, static, or abstract in Java?",
      "a": "Constructors cannot be final, static, or abstract because they must always have a body, cannot be overridden, and are used to initialize objects.",
      "x": [
        "Constructors can be static or final",
        "Constructors do not need a body",
        "Constructors belong to the class only"
      ]
    },
        {
      "position": 21,
      "topic": "Inheritance",
      "q": "What is the purpose of the ‘this’ keyword in Java?",
      "a": "‘this’ refers to the current object instance; it differentiates instance variables from local variables, can call constructors, and refer to the current class instance.",
      "x": [
        "It refers to the superclass",
        "It refers to static methods only",
        "It creates a new object automatically"
      ]
    },
    {
      "position": 22,
      "topic": "Inheritance",
      "q": "Explain the concept of Inheritance?",
      "a": "Inheritance allows a class to inherit common behavior and characteristics from a base class (IS-A relationship), promoting code reuse, method overriding, and polymorphism.",
      "x": [
        "Inheritance copies all code into child class",
        "Inheritance deletes base class methods",
        "Inheritance is only for interfaces"
      ]
    },
    {
      "position": 23,
      "topic": "Inheritance",
      "q": "Which class in Java is superclass of every other class?",
      "a": "Object class is the superclass of all classes in Java.",
      "x": [
        "String",
        "Class",
        "Main"
      ]
    },
    {
      "position": 24,
      "topic": "Inheritance",
      "q": "Why does Java not support multiple inheritance?",
      "a": "Multiple inheritance can cause ambiguity if parent classes have methods with the same signature; Java avoids this in implementation but allows multiple interfaces.",
      "x": [
        "Java cannot create more than one class",
        "Java does not support objects",
        "Multiple inheritance is slower in Java"
      ]
    },
    {
      "position": 25,
      "topic": "Inheritance",
      "q": "In OOP, what is meant by composition?",
      "a": "Composition (has-a relationship) is when a class contains an instance of another class, e.g., a Car has a SteeringWheel.",
      "x": [
        "Composition means inheriting all methods",
        "Composition deletes the contained class",
        "Composition is the same as polymorphism"
      ]
    },
    {
  "position": 26,
  "topic": "Inheritance",
  "q": "How are aggregation and composition different concepts?",
  "a": "Composition is a strong 'has-a' relationship where parts are destroyed with the whole (e.g., Car and SteeringWheel); Aggregation is weaker, parts can exist independently (e.g., Library and Students).",
  "x": [
    "Aggregation destroys all objects when parent is destroyed",
    "Composition allows parts to exist independently",
    "Aggregation is stronger than Composition"
  ]
},
{
  "position": 27,
  "topic": "Inheritance",
  "q": "Why are there no pointers in Java?",
  "a": "Java uses object references instead of pointers, avoiding direct memory access, which simplifies memory management and garbage collection.",
  "x": [
    "Java does not support objects",
    "Pointers are too slow",
    "Java cannot access memory at all"
  ]
},
{
  "position": 28,
  "topic": "Inheritance",
  "q": "If there are no pointers in Java, then why do we get NullPointerException?",
  "a": "Object references act like pointers; if a reference points to null and we access a method or field, JVM throws NullPointerException.",
  "x": [
    "NullPointerException occurs due to pointers",
    "Java never throws NullPointerException",
    "NullPointerException is caused by static methods"
  ]
},
{
  "position": 29,
  "topic": "Inheritance",
  "q": "What is the purpose of the ‘super’ keyword in Java?",
  "a": "‘super’ refers to the immediate parent class; it can call parent methods or constructors from a child class.",
  "x": [
    "‘super’ creates a new object",
    "‘super’ deletes the parent class",
    "‘super’ refers to static methods only"
  ]
},
{
  "position": 30,
  "topic": "Inheritance",
  "q": "Is it possible to use this() and super() both in the same constructor?",
  "a": "No, Java requires that either this() or super() must be the first statement; both cannot be used together.",
  "x": [
    "Yes, anywhere in the constructor",
    "Yes, only after other statements",
    "No, but only for abstract classes"
  ]
},
{
  "position": 31,
  "topic": "Inheritance",
  "q": "What is the meaning of object cloning in Java?",
  "a": "Object.clone() creates an exact copy of an object with the same class and field values, similar to a copy constructor.",
  "x": [
    "Cloning deletes the original object",
    "Cloning changes the class of object",
    "Cloning copies only primitive fields, not objects"
  ]
},

 {
    "position": 40,
    "topic": "Method Overloading and Overriding",
    "q": "What is the other name of Method Overloading?",
    "a": "Static Polymorphism.",
    "x": [
      "Dynamic Polymorphism",
      "Runtime Polymorphism",
      "Virtual Polymorphism"
    ]
  },
  {
    "position": 41,
    "topic": "Method Overloading and Overriding",
    "q": "How will you implement method overloading in Java?",
    "a": "Create multiple methods with the same name but different parameters: different number of parameters, different data types, or different sequence of data types.",
    "x": [
      "Create methods with the same name and parameters but different return types and access modifiers.",
      "Use the @Overload annotation and ensure methods have different names but similar functionality.",
      "Implement the Overloadable interface and define methods with identical signatures in different classes."
    ]
  },
  {
    "position": 42,
    "topic": "Method Overloading and Overriding",
    "q": "What kinds of argument variations are allowed in Method Overloading?",
    "a": "Different number of parameters, different data type of parameters, and different sequence of data type of parameters.",
    "x": [
      "Different return types, different access modifiers, and different exception handling clauses.",
      "Different method names, different class locations, and different package declarations.",
      "Different static modifiers, different final keywords, and different synchronized blocks."
    ]
  },
  {
    "position": 43,
    "topic": "Method Overloading and Overriding",
    "q": "Why it is not possible to do method overloading by changing return type of method in java?",
    "a": "Changing only the return type would create ambiguous behavior. The compiler wouldn't know which method to call since method calls don't always specify the expected return type.",
    "x": [
      "Return types are automatically inherited from parent classes and cannot be modified in overloaded methods.",
      "Java's JVM cannot handle different return types in memory allocation for methods with identical names.",
      "Return type changes would break the method signature contract required by the Java specification."
    ]
  },
  {
    "position": 44,
    "topic": "Method Overloading and Overriding",
    "q": "Is it allowed to overload main() method in Java?",
    "a": "Yes, you can create multiple methods named 'main' with different parameters. However, only 'public static void main(String[] args)' is used as the program entry point.",
    "x": [
      "No, main() method is reserved by Java and cannot have any variations or overloaded versions.",
      "Yes, but only if you use different access modifiers like private main() or protected main().",
      "No, overloading main() method would confuse the JVM about which method to execute first."
    ]
  },
  {
    "position": 45,
    "topic": "Method Overloading and Overriding",
    "q": "How do we implement method overriding in Java?",
    "a": "Provide a new implementation of a method with the same name in a subclass. There will be at least two implementations: one in the parent class and another in the child class.",
    "x": [
      "Use the @Override annotation and change the method signature including parameters and return type.",
      "Create a method with the same name but different access modifiers in the same class.",
      "Implement the Overridable interface and use the super keyword to modify parent behavior."
    ]
  },
  {
    "position": 46,
    "topic": "Method Overloading and Overriding",
    "q": "Are we allowed to override a static method in Java?",
    "a": "No. If you create a static method with the same name in a subclass, it's a new method, not an overridden method.",
    "x": [
      "Yes, but only if you use the @StaticOverride annotation in the subclass.",
      "Yes, static methods can be overridden but they use compile-time binding instead of runtime binding.",
      "No, but you can achieve similar functionality by using static blocks in the subclass."
    ]
  },
  {
    "position": 47,
    "topic": "Method Overloading and Overriding",
    "q": "Why Java does not allow overriding a static method?",
    "a": "To override a method, you need an instance of a class. Static methods are not associated with any instance, so the concept of overriding doesn't apply.",
    "x": [
      "Static methods are stored in a different memory area that doesn't support polymorphic behavior.",
      "Static methods are automatically final and cannot be modified by inheritance mechanisms.",
      "Static methods use compile-time optimization that prevents runtime method resolution required for overriding."
    ]
  },
  {
    "position": 48,
    "topic": "Method Overloading and Overriding",
    "q": "Is it allowed to override an overloaded method?",
    "a": "Yes. You can override an overloaded method in Java.",
    "x": [
      "No, overloaded methods are locked and cannot be overridden in subclasses.",
      "Yes, but only if the overloaded methods have the same return type.",
      "No, you must first remove the overloading before attempting to override the method."
    ]
  },
  {
    "position": 49,
    "topic": "Method Overloading and Overriding",
    "q": "What is the difference between method overloading and method overriding in Java?",
    "a": "Overloading: static polymorphism, same class, different parameters, compile-time. Overriding: runtime polymorphism, inheritance hierarchy, same parameters, runtime concept.",
    "x": [
      "Overloading uses dynamic binding while overriding uses static binding for method resolution.",
      "Overloading requires inheritance while overriding can happen within the same class structure.",
      "Overloading changes method behavior at runtime while overriding determines behavior at compile-time."
    ]
  },
  {
    "position": 50,
    "topic": "Method Overloading and Overriding",
    "q": "Does Java allow virtual functions?",
    "a": "Yes. All instance methods in Java are virtual functions by default. Only class methods and private instance methods are not virtual.",
    "x": [
      "No, Java uses interfaces instead of virtual functions for polymorphic behavior.",
      "Yes, but only if you explicitly declare methods with the 'virtual' keyword.",
      "No, Java uses abstract methods and method overriding instead of virtual functions."
    ]
  },
  {
    "position": 51,
    "topic": "Method Overloading and Overriding",
    "q": "What is meant by covariant return type in Java?",
    "a": "A covariant return type allows a method to be overridden with a 'narrower' return type. Since Java 5, if parent method returns type A, child method can return a subclass of A when overriding.",
    "x": [
      "A return type that automatically converts between primitive and wrapper types during method calls.",
      "A return type that can vary between different data types like String and Integer in overloaded methods.",
      "A return type that changes based on the input parameters passed to the overridden method."
    ]
  }
  ]
}
